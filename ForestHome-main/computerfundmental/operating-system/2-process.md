# 2 Process



## Intro

* 2.进程管理
  * （1）进程与线程
    * 1）进程概念
    * 2）进程的状态与转换
    * 3）进程控制
    * 4）进程组织
    * 5）进程通信：共享存储系统，消息传递系统，管道通信。
    * 6）线程概念与多线程模型
  * （2）处理机调度
    * 1）调度的基本概念
    * 2）调度时机、切换与过程
    * 3）调度的基本准则
    * 4）调度方式
    * 5）典型调度算法：先来先服务调度算法，短作业（短进程、短线程）优先调度算法，时间片轮转调度算法，优先级调度算法，高响应比优先调度算法，多级反馈队列调度算法
  * （3）同步与互斥
    * 1）进程同步的基本概念
    * 2）实现临界区互斥的基本方法：软件实现方法，硬件实现方法
  * （4）死锁
    * 1）死锁的概念
    * 2）死锁处理策略
    * 3）死锁预防
    * 4）死锁避免：系统安全状态，银行家算法
    * 5）死锁检测和解除

## 进程与线程

* **操作系统的重要任务之一是使用户充分、有效地利用系统资源。**
* **现代操作系统四大特点：**
  * 并发性
  * 共享性
  * 虚拟性（用户随机使用）
  * 异步性
* _采用一个什么样的概念来描述计算机程序的执行过程和作为资源分配的基本单位，才能充分反映操作系统的执行并发、资源共享及用户随机的特点呢？_
  * 即：进程
* 进程的非正式定义非常简单:进程就是运行中的程序。
  * 程序本身是没有生命周期的,它只是存在磁盘上面的一些指令(也可能是一些静态数据) 。
  * 是操作系统让这些字节运行起来,让程序发挥作用。

**进程是一种最重要、最基本的 OS 抽象概念之一**

### 进程的概念

在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。 **为此引入了进程(Process)的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。**

* 为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block, PCB)。
* 系统利用 PCB 来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和 PCB 三部分构成了进程映像（进程实体）。
* **所谓创建进程，实质上是创建进程映像中的 PCB；而撤销进程，实质上是撤销进程的 PCB。** 值得注意的是，进程映像是静态的，进程则是动态的。
* _**PCB 是进程存在的唯一标志**_
* **主要关注动态的执行过程这一概念。**
  * 即：并发执行的程序在执行过程中分配和管理资源的基本单位。
  * 从理论角度看，进程是一种对整个程序运行过程的抽象。（面向过程？啧啧）
  * 从实现角度看，是一种数据结构，目的在于清晰地**刻画动态系统的内在规律**，**有效管理和调度**进入计算机系统主存储器运行的程序。
* 从不同的角度，进程可以有不同的定义，比较典型的定义有：
  * 进程是程序的一次执行过程。
  * 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
  * 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。

**在引入进程实体的概念后，我们可以把传统操作系统中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。”**

### 进程的特征

**进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。**

1. **动态性**：进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。
2. **并发性**：指多个进程实体，同存于内存中，能在一段时间内同时运行，并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率。
3. **独立性**：指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立 PCB 的程序都不能作为一个独立的单位参与运行。
4. **异步性**：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、 不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此，在操作系统中必须配置相应的进程同步机制。
5. **结构性**：每个进程都配置一个 PCB 对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制段三部分组成的。

### 进程的组织与描述

进程是操作系统的资源分配和独立运行的基本单位。它一般由以下三个部分组成。

_一个进程是一个程序对某个数据集的执行过程，是分配资源的基本单位。那么，从处理机的活动角度来看，又如何识别描述程序执行活动的进程呢？_

* **进程的静态描述**
  * 是系统中描述进程存在和反应其变化的物理实体 $$进程的静态描述 = 进程控制块 PCB + 程序段 + 数据结构集$$ ^d59453
* 进程控制块 PCB：进程的描述信息、控制信息和资源信息。进程动态特征的集中反馈。
* 程序段
* 数据集：程序执行时必不可少的工作区与操作对象。

#### 进程控制块 PCB

**进程创建时，操作系统就新建一个 PCB 结构，它之后就常驻内存，任一时刻可以存取, 在进程结束时删除。PCB 是进程实体的一部分，是进程存在的唯一标志。**

* 包含一个进程的描述信息，控制信息和资源信息。
* **PCB 集中反应一个进程的动态特征。**
* 进程并发执行时，由于资源共享，带来各进程之间的相互制约。
* **PCB 反映制约关系和资源共享关系**
  * 在创建一个进程时，应首先创建其 PCB,然后才能根据 PCB 中的信息对进程实施有效的管理和控制。
  * 当一个进程完成其功能之后，系统释放 PCB,进程也随之消亡。

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207251539365.png)

* **PCB 包含内容：**
  * 描述信息：编号，标识号等
  * 控制信息：进程当前状态，优先级，占用内存的时间 etc.
  * **资源分配清单**：说明地址空间的状况；所打开文件的列表和所使用的 IO 设备信息。
  * **资源管理信息**：包含最多 包括存储器，IO 和文件系统的信息
  * CPU 现场保护结构：为中断做准备 存储退出执行时进程的现场数据
  * **处理机相关信息**，主要指处理机中各寄存器值，当进程被切换时，处理机状态信息 都必须保存在相应的 PCB 中，以便在该进程重新执行时，能再从断点继续执行。

> 总之，**PCB 是系统感知进程存在的唯一实体。** 通过对 PCB 的操作，系统为有关进程分配资源从而使得有关进程得以被调度执行；而完成进程所要求功能的程序段的有关地址，以及程序段在进程过程中因某种原因被停止执行后的现场信息也都在 PCB 中。最后，当进程执行结束后，则通过释放 PCB 来释放进程所占有的各种资源。

* 进程的组织：
  * 将各进程的 PCB 用适当的方法组织起来。
* 进程的组织方式：
  * 链接方式将同一状态的 PCB 链接成一个队列，不同状态对应不同的队列，也可以把处于阻塞状态的进程的 PCB，根据其阻塞原因的不同，排成多个阻塞队列。
  * 索引方式是将同一状态的进程组织在一个索引表中，索引表的表项指向相应的 PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。

#### 进程上下文

进程上下文即：有关**程序段**和**数据集**。

即： $$进程 = 进程控制块 PCB \ + 进程上下文$$

* **程序段**
  * **程序段就是能被进程调度程序调度到 CPU 执行的程序代码段。**
  * 注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序。
* **数据段**
  * **一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。**
* **进程上下文集中反映一个进程的静态描述**
  * 进程上下文是一个与进程切换和处理机状态发生交换有关的概念。在进程执行过程中，由于中断、等待或程序出错等原因造成进程调度，这时操作系统需要知道和记忆进程已经执行到什么地方或新的进程将从何处执行。
  * 进程执行过程中调用子程序执行后， 进程将返回何处继续执行，执行结果将返回或存放到什么地方等都需要进行记忆。
  * 进程上下文主要用于进程切换时，处理机状态发生交换或调用子程序时，OS 记忆当前进程执行的内容和中断发生的位置，以便返回继续执行。
* **进程上下文是一个抽象的概念。**
  * 其包含了每个进程执行过的、执行时的以及待执行的指令和数据，在指令寄存器、堆栈（存放各调用子程序的返回点和参数等）和状态字寄存器等中的内容。
* **上文**：
  * 已经执行过的进程指令和数据相关寄存器与堆栈中的内容。
* **正文**：
  * 正在执行的进程和数据在寄存器中的堆栈。
* **下文**：
  * 待执行的部分。
* **不同进程间的进程上下文切换只在发生进程调度时出现**
  * _在不发生进程调度时，进程上下文的改变都是在同一进程内进行的_，此时，每条指令的执行对进程上下文的改变较小，一般反映为指令寄存器、程序计数器以及保存调用子程序返回接口用的堆栈值等的变化。
* 同一进程的上下文的结构由与执行该进程有关的各种寄存器中的值、程序段经过编译后形成的机器指令代码集（或称正文段）、数据集及各种堆栈值与 PCB 结构构成。
  * 这里，有关寄存器和栈区的内容是重要的。例如，没有程序计数器 P 和程序状态字寄存器 PSW, CPU 将无法知道下条待执行指令的地址和控制有关操作。
  * **进程上下文在底层还可以看做是各种控制表指针与寄存器的结合**

### 进程的状态与转换

**进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化（一个进程会经历若干种不同状态）。通常进程有以下五种状态，前三种是进程的基本状态。**

1. **运行状态**：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。
2. **就绪状态**：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。
3. **阻塞状态**，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。
4. **创建状态**：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源；最后把该进程转入到就绪状态。
5. **结束状态**：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。

> 注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待（阻塞）状态是指进程需要其他资源（除了处理机）或等待某一事件。
>
> 之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的；而其他资源（如外设）的使用和分配或者某一事件的发生（如 I/O 操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。
>
> 这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，很显然需要加以区分。

* 进程状态转换图
  * ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202206142054634.png)
* 将这些进程的不同状态进行智能转换和调度的操作是一个更加重要的议题，即\[\[#处理机调度|进程调度]]
* **就绪状态 -> 运行状态：**
  * 处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。
* **运行状态 -> 就绪状态：**
  * 处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。
* **运行状态 -> 阻塞状态：**
  * 当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如 I/O 操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。
* **阻塞状态 -> 就绪状态：**
  * 当进程等待的事件到来时，如 I/O 操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。

### 进程控制

**进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。**

* 在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。

#### 进程的创建与撤销

* 允许一个进程创建另一个进程。
  * 此时创建者称为父进程，被创建的进程称为子进程。
  * 子进程可以继承父进程所拥有的资源。
  * 当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。
  * 此外，在撤销父进程时，也必须同时撤销其所有的子进程。

**创建原语的使用**

* 在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语)：
  1. 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB(PCB 是有限的)。若 PCB 申请失败则创建失败。
  2. 为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在 PCB 中体现）。注意：这里如果资源不足（比如内存空间），并不是创建失败，而是处于”等待状态“，或称为“阻塞状态”，等待的是内存这个资源。
  3. 初始化 PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。
  4. 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。

***

* 引起进程终止的事件主要有：
  * 正常结束：表示进程的任务已经完成和准备退出运行。
  * 异常结束：是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O 故障等。
  * 外界干预：进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。

**撤销原语的使用**

* 操作系统终止进程的过程如下（撤销原语）：
  1. 根据被终止进程的标识符，检索 PCB，从中读出该进程的状态。
  2. 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。
  3. 若该进程还有子进程，则应将其所有子进程终止。
  4. 将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。
  5. 将该 PCB 从所在队列（链表）中删除。

#### 进程的阻塞与唤醒

正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。

* 可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得 CPU），才可能将其转为阻塞状态。

**阻塞原语的使用**

* 阻塞原语的执行过程是：
  1. 找到将要被阻塞进程的标识号对应的 PCB。
  2. 若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。
  3. 把该 PCB 插入到相应事件的等待队列中去。

***

当被阻塞进程所期待的事件出现时，如它所启动的 I/O 操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒。

**唤醒原语的使用**

* 唤醒原语的执行过程是：
  1. 在该事件的等待队列中找到相应进程的 PCB。
  2. 将其从等待队列中移出，并置其状态为就绪状态。
  3. 把该 PCB 插入就绪队列中，等待调度程序调度。

> **需要注意的是，Block 原语和 Wakeup 原语是一对作用刚好相反的原语，必须成对使用。 Block 原语是由被阻塞进程自我调用实现的，而 Wakeup 原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的。**

#### 进程上下文切换

对于通常的进程，其创建、撤销以及要求由系统设备完成的 I/O 操作都是利用系统调用而进入内核，再由内核中相应处理程序予以完成的。**进程切换同样是在内核的支持下实现的**，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

**进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化。**

* **提出进程上下文的概念主要是为了上下文切换**
  * \==进程上下文切换发生在不同进程之间而不是一个进程内。==
  * **发生时间：系统做进程调度时出现**
* 进程上下文切换过程一般包含 3 个部分，并涉及 3 个进程。
  1. 保存被切换进程的正文部分（或当前状态）至有关存储区
  2. 操作系统进程中有关调度和资源分配程序执行
  3. 将被选中进程的原来被保存的正文部分从有关存储区中取出，并送至有关寄存器与堆栈中，激活被选中进程执行。
* **进程空间与大小**
  * 任一进程都有自己的地址空间，该空间称为进程空间或虚空间。
  * 进程空间大小只与处理机位数有关。
  * 还被划分为用户空间和系统空间+用户态和系统态。
  * 进程的大小就是进程空间的大小。
* 进程切换的过程如下：
  1. 保存处理机上下文，包括程序计数器和其他寄存器。
  2. 更新 PCB 信息。
  3. 把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。
  4. 选择另一个进程执行，并更新其 PCB。
  5. 更新内存管理的数据结构。
  6. 恢复处理机上下文。

> 注意，进程切换与处理机模式切换是不同的。
>
> 模式切换时，处理机逻辑上可能还在同一进程中运行。如果进程因中断或异常进入到核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的 CPU 现场，无需改变当前进程的环境信息。
>
> 但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变

* 为了提高进程上下文切换效率，提出了多组寄存器技术。**为了进一步提升效率，提出了线程的概念。**

### 进程通信

进程通信是指进程之间的信息交换。**PV 操作是低级通信方式**，**髙级通信方式是指以较高的效率传输大量数据的通信方式**。高级通信方法主要有以下三个类。

#### 共享存储

在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。

* 在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P 操作、V 操作），对共享空间的写/读进行控制。
* 共享存储又分为两种：
  * **低级方式的共享是基于数据结构的共享**；
  * **高级方式则是基于存储区的共享**。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。
* 需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。

#### 消息传递

**在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。**

若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。

1. 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。
2. 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。

#### 管道通信

**管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名 pipe 文件。**

* 向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。
* 为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。

## 线程

### 线程的基本概念

**引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。**

* _Q：为什么引入线程？_
  * \==进程是为了提高 CPU 的执行效率==，减少因为程序等待带来的 CPU 空转以及其他计算机软硬件资源的浪费而提出来的。进程是为了完成用户任务所需要的程序的一次执行过程以及为其分配资源的一个基本单位。
* _Q：为什么不能通过创建很多进程的方式来实现？_
  * 系统资源角度：理论上存在父进程和创建很多子进程的方式来实现高并发。但创建一个进程需要很大的系统开销和占用很多系统资源：至少要消耗一个 PCB 结构。若子进程过多，则占有系统的资源也越多。
  * 并发访问数量角度：并且针对于不确定的用户数以及随机访问的 Web 服务而言，用进程来管理用户会极大限制访问服务器的用户数
  * 进程调度角度：不同的用户子进程还涉及频繁的进程上下文切换

\==为了减少进程切换和创建的开销，提高执行效率和节省资源，引入了线程（Thread）的概念。==

* 线程最直接的理解就是“轻量级进程”，它是一个基本的 CPU 执行单元，也是程序执行流的最小单元，由线程 ID、程序计数器、寄存器集合和堆栈组成。
* 线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。
* 一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。

_**引入线程后，进程的内涵发生了改变，进程只作为除 CPU 以外系统资源的分配单元，线程则作为处理机的分配单元。**_ ==进程是系统资源分配时的基本单位== ==线程是 CPU 分配的基本单位==

### 线程与进程的比较

* **调度**
  * 在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。
  * 在引入线程的操作系统中，线程是独立调度的基本单位，进程是资源拥有的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。
* **资源**
  * 不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点必不可少的资源），但线程可以访问其隶属进程的系统资源。
  * 进程拥有一个完整的虚拟地址空间。
* **并发性**
  * 在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。
* **系统开销**
  * 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、 I/O 设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。
  * 类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度到进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
  * 此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。
* **地址空间和其他资源**（如打开的文件）：
  * 进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。
* **通信方面**：
  * 进程间通信(IPC)需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。

### 线程的属性

在多线程操作系统中，把线程作为独立运行（或调度）的基本单位，此时的进程，已不再是一个基本的可执行实体。但进程仍具有与执行相关的状态，所谓进程处于“执行”状态，实际上是指该进程中某线程正在执行。

* 线程的主要属性如下：
  1. 线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。
  2. 不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统为它们创建成不同的线程。
  3. 同一进程中的各个线程共享该进程所拥有的资源。
  4. 线程是处理机的独立调度单位，多个线程是可以并发执行的。在单 CPU 的计算机系统中，各线程可交替地占用 CPU；在多 CPU 的计算机系统中，各线程可同时占用不同的 CPU，若各个 CPU 同时为一个进程内的各线程服务则可缩短进程的处理时间。
  5. —个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。
* **引入线程后的重要结论和改变**
  * 在引入线程前，进程的两个基本属性是：1.可拥有资源的独立单位。2.可独立调度和分配的基本单位。
  * 后来为了使多个程序更好的并发执行，人们把上述两个属性分开，引入线程作为可独立调度和分配的基本单位。
  * **在无线程的系统中，进程是资源调度和并发执行的基本单位。在引入线程的系统中，进程退化为资源分配的基本单位，而线程代替进程被操作系统调度。** 线程便可以并发执行。
* **线程控制块 TCB**
  * 与进程控制表和 PCB 相似，每个线程也有自己的线程控制块(TCB)。
  * 这个 TCB 中所保存的线程状态信息则要比 PCB 少得多，这些信息主要是相关指针用堆栈（系统栈和用户栈)以及寄存器中的状态数据。

使用线程的最大好处是在有多个任务需要处理机处理时可以减少处理机的切换时间； 而且，线程的创建和结束所需要的系统开销也比进程要小得多。由此，可以推出最适合使用线程的系统是多处理机系统、网络系统或分布式系统。

* **典型应用：**
  * 服务器中文件管理或通信控制
  * 前后台处理
  * 异步处理

### 线程的实现方式

线程的实现可以分为两类：用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread,  KLT)。内核级线程又称为内核支持的线程。

* **用户级线程**
  * 有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。
  * 应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。图 2-2(a)说明了用户级线程的实现方式。
* **内核级线程**
  * 线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。
  * 内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。图 2-2(b)说明了内核级线程的实现方式。
  * 由操作系统 kernel 进行管理。kernel 给应用程序提供相应的\[\[1.5 操作系统用户界面#接口 2-系统调用|系统调用]]和 API，以使用户程序可以创建，执行和撤销线程。
  * 与用户线程不同，==内核级线程既可以被调度到一个处理机上并发执行，也可以被调度到不同的处理机上并行执行。操作系统内核既负责进程的调度，也负责进程内不同线程的调度工作==。因此，内核级线程不会出现_进程处于阻塞或等待状态，而线程处于执行状态的情况_。
  * 内核级线程也可用于内核程序自身，以提高 OS 内核程序执行效率。
* 在一些系统中，使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。图 2-2(c)说明了用户级与内核级的组合实现方式。

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207251547344.png)

\==线程无挂起/等待状态，即线程是一个只与内存和寄存器相关的概念，其内容不会因 swap 进入外存。==

### 多线程模型

**有些系统同时支持用户线程和内核线程由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。**

**多对一模型**

* **将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。**
* 此模式中，用户级线程对操作系统不可见（即透明）。
  * 优点：线程管理是在用户空间进行的，因而效率比较高。
  * 缺点：当一个线程在使用内核服务时被阻塞，那么整个进程都会被阻塞；多个线程不能并行地运行在多处理机上。

**一对一模型**

* **将每个用户级线程映射到一个内核级线程。**
  * 优点：当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。
  * 缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。

**多对多模型**

* **将 n 个用户级线程映射到 m 个内核级线程上，要求 m <= n。**
  * 特点：在多对一模型和一对一模型中取了个折中，克服了多对一模型的并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程，开销太大的缺点。
  * 又拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。

## 处理机调度

### 调度的基本概念

在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、髙效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

**处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题。**

***

#### 调度的层次

一个作业从提交开始直到完成，往往要经历以下三级调度

**作业调度**

_**——完成的是作业从后备状态到执行状态的转变，以及从执行状态到完成状态的转变。**_

* 又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，以**使它获得竞争处理机的权利**。
* 简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。
* 多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。
* **作业调度的本质：是对除 CPU 之外的所有系统硬件资源的分配。**
* 作业调度的功能内容
  * **记录系统中各作业的状况，包括执行阶段的有关状况。**
    * 为每个作业建立 JCB
    * 确定当前作业的执行状态
  * **从后备队列中挑选出一部分作业投入执行。**
    * 系统中处于后备状态的进程很多，取决于外存输入井的大小。
    * 作业调度程序根据相应的作业调度算法选择相应的作业投入执行。
  * **为被选中作业做好执行前准备工作。**
    * 为选中的作业建立相应的进程；并为这些进程分配相应的系统资源如内存，外存和外设。
  * **在作业执行结束后做好善后工作。**
    * 输出作业管理信息
    * 回收作业占有的系统资源，撤销进程和作业的控制块
* _Q：怎样从后备队列挑选一批作业进入执行状态呢？_
  * **作业调度的主要目标：**
    1. 对所有作业公平合理
    2. 应使设备有高的利用率
    3. 每天执行尽可能多的作业
    4. 有快的响应时间

**中级调度**

* 又称内存调度。**引入中级调度是为了提高内存利用率和系统吞吐量**。
  * 为此，应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。
  * 其主要任务是按照给定的原则和策略，**将处于外存交换区中的就绪状态或等待状态的进程调入内存**，或把处于**内存就绪状态或内存等待状态的进程交换到外存交换区**。
* 当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。

**进程调度**

_**——进程调度本质——选择一个合适的进程占据处理机**_

* 又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
* 进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。
* 进程调度的频率很高，一般几十毫秒一次。
* **进程调度的主要功能**
  * **记录系统中所有进程的执行情况**——通过 PCB
    * 将系统中各进程的执行情况和特征记录在 PCB 中；并将其进行动态队列转接。
    * 进程调度模块通过 PCB 掌握进程状态信息从而做出选择占据处理机的进程。
  * **选择占有处理机的进程**——_**利用进程调度算法**_
    * 进程调度的主要功能便是按照一定的策略选择一个处于就绪状态的进程，使其获得处理机并执行。
    * 根据不同的系统设计目的，有不同的调度算法或策略可供选择：静态优先级调度法；Round Robin；多级反馈轮转法等。这些选择策略决定了调度算法的性能。
  * **进行进程上下文切换**
    * 检查是否可以进行上下文切换
    * 保存信息
    * 选择一个处于就绪状态的进程进行装配。

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207251614412.png)

***

**三级调度之间的联系：**

* _作业调度_从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列
* _进程调度_从就绪队列中选出一个进程，并把其状态改为运行状态，把 CPU 分配给它。
* _中级调度_是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。
* 一些额外的解释：
  * 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。
  * 作业调度次数少，中级调度次数略多，进程调度频率最高。
  * 进程调度是最基本的，不可或缺。

### 调度的时机、切换与过程

**进程调度和切换程序是操作系统内核程序**。

> 当请求调度的事件发生后，才可能会运行进程调度程序； 当调度了新的就绪进程后，才会去进行进程间的切换。
>
> 理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。

* _Q：何时进行进程调度？_
  * 与引起进程调度的原因与其调度方式有关。

**不能立即进行进程调度并上下文切换的情况：**

* 如果在以下过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。
* 现代操作系统中，不能进行进程的调度与切换的情况有以下几种情况。
  * 在处理中断的过程中：
    * 中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。
  * 进程在操作系统内核程序临界区中：
    * 进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。
  * 其他需要完全屏蔽中断的原子操作过程中：
    * 如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。

**应该立即进行进程调度并上下文切换的情况：**

* 应该进行进程调度与切换的情况有：
  * 当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度。
  * 当中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。

**进程切换往往在调度完成后立刻发生**，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。

现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。

内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设 PC 寄存器等相关工作之后，开始运行新的进程。

### 调度的基本准则

不同的调度算法具有不同的特性，在选择调度算法时，**必须考虑算法所具有的特性**。为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种：

* **CPU 利用率**。
  * CPU 是计算机系统中最重要和昂贵的资源之一，所以应尽可能使 CPU 保持“忙”状态，使这一资源利用率最髙。
* **系统吞吐量**。
  * 表示单位时间内 CPU 完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。
* **周转时间**。
  * 是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入/输出操作所花费时间的总和。
* **等待时间**。
  * 是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。
* **响应时间**。
  * 是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内
* **作业的周转时间**可用公式表示如下： $$T_i = 作业完成时间 - 作业提交时间$$ $$T_i = T_w + T_r$$ 即等待时间+执行时间
* **平均周转时间**是指多个作业周转时间的平均值：
  * 平均周转时间 = (作业 1 的周转时间 + … + 作业 n 的周转时间) / n
* **带权周转时间**是指作业周转时间与作业实际运行时间的比值：
  * ![](http://c.biancheng.net/cpp/uploads/allimg/140629/1-140629151603410.png)
  * 为了进一步反应调度性能，引入了带权周转时间的概念。
  * 带权周转时间是作业周转时间与作业执行时间之比。 $$W = T_i \ / \ T_r$$

> 要想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程快速响应要求)，另一方面要考虑系统整体效率（如减少整个系统进程平均周转时间），同时还要考虑调度算法的开销。

### 典型调度算法

在操作系统中存在多种调度算法，其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。下面介绍几种常用的调度算法。

#### FCFS

——_**先来先服务**_ **FCFS 调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。**

* 在作业调度中：
  * 算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。
* 在进程调度中：
  * FCFS 调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。

[FCFS 具体性能分析](http://c.biancheng.net/cpp/html/2595.html)

* FCFS 调度算法属于不可剥夺算法。
  * 从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，**因此它不能作为分时系统和实时系统的主要调度策略**。
  * **但它常被结合在其他调度策略中使用**。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按 FCFS 原则处理。

**FCFS 的特点**：

* FCFS 调度算法的特点是算法简单，但效率低；
* 对长作业比较有利，但对短作业不利（相对 SJF 和高响应比）；
* 有利于 CPU 繁忙型作业，而不利于 I/O 繁忙型作业。

#### 短作业优先 SJF

**短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。**

* 短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。
* 而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。

[短作业具体性能分析](http://c.biancheng.net/cpp/html/2595.html)

_**注意，SJF 调度算法的平均等待时间、平均周转时间最少。**_

* **SJF 调度算法的吞吐量是最大的。**
* SJF 调度算法也存在不容忽视的缺点：
  * 该算法对长作业不利，SJF 调度算法中长作业的周转时间会增加。
  * 更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些 (即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）。
  * 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。
  * 由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。

#### 优先级调度算法

_**——系统或用户按某种原则为作业或进程指定优先级作为调度优先权。**_ **优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。**

* 在作业调度：
  * 优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。
* 在进程调度：
  * 优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。
* **根据新的更高优先级进程能否抢占正在执行的进程**，可将该调度算法分为：
  * 非剥夺式优先级调度算法。
    * 当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。
  * 剥夺式优先级调度算法。
    * 当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。
* **而根据进程创建后其优先级是否可以改变**，可以将进程优先级分为以下两种：
  * 静态优先级。
    * 优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。
  * 动态优先级。
    * 在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有 CPU 时间的长短、就绪进程等待 CPU 时间的长短。

#### 高响应比优先 HRN

_**——最高响应比优先法是对 FCFS 方式和 SJF 方式的一种综合平衡。**_ **高响应比优先调度算法主要用于作业调度，该算法是对 FCFS 调度算法和 SJF 调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间**。

* 在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。

相应比的计算： $$响应比 Rp = \frac{等待时间+要求服务时间}{要求服务时间}$$

* **每当要进行作业调度时，系统计算每个作业的响应比，选择其中 R 最大者投入执行。**
  * 这样，即使是长作业，随着它等待时间的增加，W/T 也就随着增加，也就有机会获得调度执行。
  * \==这种算法是介于 FCFS 和 SJF 之间的一种折中算法。==

**优点：**

* 当作业的等待时间相同时，则要求服务时间越短，其响应比越高，**有利于短作业**。
* 当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，**因而它实现的是先来先服务**。
* 对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。**克服了饥饿状态，兼顾了长作业**。

**缺点：**

* 由于长作业也有机会投入运行， 在同一时间内处理的作业数显然要少于 SJF 法，从而采用 HRN 方式时其吞吐量将小于采用 SJF 法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。

#### 时间片轮转调度算法 Round Robin

_**——让每个进程在就绪队列中的等待时间与享受服务的时间成比例。**_

**时间片轮转调度算法主要适用于分时系统。**

* **轮转法最重要的要点是利用了分时操作系统中的时间片思想**
  * 轮转法的基本概念是将 CPU 的处理时间分成固定大小的时间片。
  * 如果一个进程在被调度选中之后用完了系统规定的时间片，但未完成要求的任务，则它自行释放自己所占有的 CPU 而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程或作业。
* **轮转法只能用来调度分配那些可以抢占的资源。将他们随时剥夺再分配给别的进程。**
  * CPU 属于可抢占的一种；打印机便属于不可抢占的资源。

> **作业调度的本质：是对除 CPU 之外的所有系统硬件资源的分配。** ——_而作业调度中包含了对不可抢占资源的分配。所以作业调度不适用轮转法。_

* 在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如 100ms。
* 在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。

**在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。**

* **轮转法时间片的选择**
  * 时间片长度的选择会直接影响系统开销和响应时间。
  * 若时间片长度过短
    * 则调度程序剥夺处理机的次数增多，这将使进程上下文切换次数也大大增加，从而加重系统开销。
  * 若时间片长度选择过长
    * 轮转法退化为了 FCFS：一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕
* 时间片的长短通常由以下因素确定：
  * 系统的响应时间
  * 就绪队列中的进程数目
  * 系统的处理能力。

#### 多级反馈队列调度算法

_**——利用不同的到达时间和所需服务时长分为不同的就绪队列，每个队列按照 FCFS 方式排列；各队列间享有不同的优先级。同一队列内优先级相同。 综合了前几种算法的优点**_

**多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展。**

* 当一个进程执行完其时间片，或被唤醒以及被创建后，将进入不同的就绪队列。
* **轮转法加入就绪队列的三种情况**
  * 分给进程的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度继续执行。
  * 分给该进程的时间片未用完，只是因为请求 I/O 或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。
  * 新创建进程进入就绪队列。
* **通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。**
  * 例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的 I/O 设备利用率和缩短响应时间而照顾 I/O 型进程；同时，也不必事先估计进程的执行时间。
* 算法细节：
  * 设置多级就绪队列，各队列优先级从高到低，时间片从小到大。
  * 新进程到达时先进入第 1 级队列，按照 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回该队列队尾。
  * 只有第 K 级队列为空时，才会为 K+1 级对头的进程分配时间片

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207261641147.png)

![](https://img-blog.csdnimg.cn/0fb88e027ced440d84a3cf53fc350230.png?x-oss-process=image/watermark,type\_d3F5LXplbmhlaQ,shadow\_50,text\_Q1NETiBA4oCNb09vT29Pb29PTw==,size\_20,color\_FFFFFF,t\_70,g\_se,x\_16)

* 多级反馈队列调度算法的实现思想如下：
  * 应设置多个就绪队列，并为各个队列赋予不同的优先级，第 1 级队列的优先级最高，第 2 级队列次之，其余队列的优先级逐次降低。
  * 赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。
    * 例如，第 2 级队列的时间片要比第 1 级队列的时间片长一倍， ……第 i+1 级队列的时间片要比第 i 级队列的时间片长一倍。
  * 当一个新进程进入内存后，首先将它放入第 1 级队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第 2 级队列的末尾，再同样地按 FCFS 原则等待调度执行；
    * 如果它在第 2 级队列中运行一个时间片后仍未完成，再以同样的方法放入第 3 级队列……如此下去，当一个长进程从第 1 级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。
  * 仅当第 1 级队列为空时，调度程序才调度第 2 级队列中的进程运行；仅当第 1 \~ (i-1)级队列均为空时，才会调度第 i 级队列中的进程运行。如果处理机正在执行第 i 级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 \~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 级队列的末尾，把处理机分配给新到的更高优先级的进程。
* **根据就绪原因给予不同优先级改善效率**
  * 将就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列
  * 每个队列按 FCFS 原则排列，各队列之间的进程享有不同的优先级，但同一队列内优先级相同
  * 当一个进程在执行完它的时间片之后，或从睡眠中被唤醒以及被创建之后，将进入不同的就绪队列。
* **多级反馈轮转法与优先级法的区别：**
  * 一个进程在执行结束前，可能需要反复多次通过反馈循环执行。
  * 本质上是优先级可以通过不同级别进行实时改变的一种方法——并非优先级法中的一次执行。
* **多级反馈队列的优势有：**
  * 终端型作业用户：短作业优先。
  * 短批处理作业用户：周转时间较短。
  * 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。

## 同步与互斥

### 互斥

#### 资源共享引起的制约

资源有限，导致进程之间的资源竞争和共享。因此，进程的并发执行不仅仅是用户程序的执行开始时间的随机性和提高资源利用率的结果，也是资源有限性导致资源的竞争与共享对进程的执行过程进行制约导致的。

* **临界区**
  * 不允许并发进程交叉执行的一段程序。
  * 是由不属于多个并发进程的程序段共享公用数据或公用数据变量引起的。临界区不可能用增加硬件的方法解决。因此，临界区也可被称为访问公共数据的那段程序。
* **间接制约**
  * 把这种由于==共享某一公有资源==而引起的在临界区内不允许并发进程交叉执行的现象， 称为由共享公有资源而造成的对并发进程执行速度的间接制约。
* **互斥**
  * **不允许两个以上的共享该资源的并发进程同时进入临界区。**

> 一组并发进程互斥执行时必须满足如下准则：
>
> 1. 不能假设各并发进程的相对执行速度。即各并发进程享有平等地、独立地竞争共有资源的权利，且在不采取任何措施的条件下，在临界区内任一指令结束时，其他并发进程可以进入临界区。
> 2. 并发进程中的某个进程不在临界区时，它不阻止其他进程进入临界区。
> 3. 并发进程中的若干个进程申请进入临界区时，只能允许一个进程进入。
> 4. 并发进程中的某个进程从申请进入临界区时开始，应在有限时间内得以进入临界区。

* 1,2,3 保证各父进程享有平等、独立竞争和使用公有资源的权利，且保证同一时间至多有一个进程在临界区。
* 4 是并发进程不发生死锁的重要保证。否则由于某个并发进程长期占有临界区，其他进程则因为不能进入临界区而进入互相等待状态

#### 临界资源

* 虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。
  * 许多物理设备都属于临界资源，如打印机等。
  * 此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。
* 对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。
* 为了保证临界资源的正确使用，可以把临界资源的访问过程分成四个部分：
  * 进入区：
    * 为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。
  * 临界区：
    * 进程中访问临界资源的那段代码，又称临界段。
  * 退出区：
    * 将正在访问临界区的标志清除。
  * 剩余区：
    * 代码中的其余部分。

```c
do {
    entry section;  //进入区
    critical section;  //临界区
    exit section;  //退出区
    remainder section;  //剩余区
} while (true)
```

#### 互斥

**互斥亦称间接制约关系**。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。

```
例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。
```

* 为禁止两个进程同时进入临界区，同步机制应遵循以下准则：
  * 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
  * 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
  * 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。
  * 让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待

#### 进程合作引起的制约

* **直接制约**
  * 一组在异步环境下的并发进程，各自的执行结果互为对方的执行条件，从而限制各进程的执行速度的过程称为并发进程间的直接制约。
  * 异步环境主要是指各并发进程的执行起始时间的随机性和执行速度的独立性。

#### 同步

**同步亦称直接制约关系**，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。

**进程间的直接制约关系就是源于它们之间的相互合作。**

```
例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。
```

## 实现临界区互斥的基本方法

### 软件实现方法

在进入区设置和检查一些标志来标明是否有进程在临界区中，如果已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。

#### 单标志法

* 该算法设置一个公用整型变量 turn,用于指示被允许进入临界区的进程编号，即若 turn=0，则允许 P0 进程进入临界区。该算法可确保每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，如果某个进程不再进入临界区了，那么另一个进程也将进入临界区（违背“空闲让进”）这样很容易造成资源利用的不充分。

```c
1.  // P0进程
2.  while(turn!=0);
3.  critical section;
4.  turn=1;
5.  remainder section;

1.  // P1进程
2.  while(turn!=1);  // 进入区
3.  critical section;  // 临界区
4.  turn = 0;  // 退出区
5.  remainder section;  // 剩余区
```

#### 双标志法先检查

* 该算法的基本思想是在每一个进程访问临界区资源之前，先查看一下临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。为此，设置了一个数据 flag\[i]，如第 i 个元素值为 FALSE，表示 Pi 进程未进入临界区，值为 TRUE，表示 Pi 进程进入临界区。

```c
1.  // Pi 进程
2.  while(flag[j]);  // ①    
3.  flag[i]=TRUE;  // ③  
4.  critical section;   
5.  flag[i] = FALSE; 
6.  remainder section;

1.  // Pj 进程
2.  while(flag[i]);  // ② 进入区
3.  flag[j] =TRUE;  // ④ 进入区
4.  critical section;  // 临界区
5.  flag[j] = FALSE;  // 退出区
6.  remainder section;  // 剩余区
```

* 优点：不用交替进入，可连续使用；缺点：Pi 和 Pj 可能同时进入临界区。按序列①②③④ 执行时，会同时进入临界区（违背“忙则等待”)。即在检查对方 flag 之后和切换自己 flag 之前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行。

#### 双标志法后检查

* 算法二是先检测对方进程状态标志后，再置自己标志，由于在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后，同时进入临界区。为此，算法三釆用先设置自己标志为 TRUE 后,再检测对方状态标志，若对方标志为 TURE，则进程等待；否则进入临界区。

```c
1.  // Pi进程
2.  flag[i] =TRUE;
3.  while(flag[j]);
4.  critical section;
5.  flag[i] =FLASE;
6.  remainder section;

1.  // Pj进程
2.  flag[j] =TRUE;  // 进入区
3.  while(flag[i]);  // 进入区
4.  critical section;  // 临界区
5.  flag [j] =FLASE;   // 退出区
6.  remainder section;  // 剩余区
```

* 当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值 flag 设置为 TRUE，并且同时检测对方的状态（执行 while 语句），发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。

#### Peterson’s Algorithm

* 为了防止两个进程为进入临界区而无限期等待，又设置变量 turn，指示不允许进入临界区的进程编号，每个进程在先设置自己标志后再设置 turn 标志，不允许另一个进程进入。这时，再同时检测另一个进程状态标志和不允许进入标志，这样可以保证当两个进程同时要求进入临界区，只允许一个进程进入临界区。

```c
1.  // Pi进程
2.  flag[i]=TURE; turn=j;
3.  while(flag[j]&&turn==j); 
4.  critical section;
5.  flag[i]=FLASE;
6.  remainder section;

1.  // Pj进程
2.  flag[j] =TRUE;turn=i;  // 进入区
3.  while(flag[i]&&turn==i);   // 进入区
4.  critical section;  // 临界区
5.  flag[j]=FLASE;  // 退出区
6.  remainder section;  // 剩余区
```

* 本算法的基本思想是算法一和算法三的结合。利用 flag 解决临界资源的互斥访问，而利用 turn 解决“饥饿”现象。

### 硬件实现方法

本节对硬件实现的具体理解对后面的信号量的学习很有帮助。计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。通过硬件支持实现临界段问题的低级方法或称为元方法。

#### 中断屏蔽方法

* 当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单方法是禁止一切中断发生，或称之为屏蔽中断、关中断。
* 因为 CPU 只在发生中断时引起进程切换，这样屏蔽中断就能保证当前运行进程将临界区代码顺利地执行完，从而保证了互斥的正确实现，然后再执行开中断。其典型模式为： … 关中断; 临界区; 开中断; …
* 这种方法限制了处理机交替执行程序的能力，因此执行的效率将会明显降低。
* 对内核来说，当它执行更新变量或列表的几条指令期间关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断之后不再开中断，则系统可能会因此终止。

#### 硬件指令方法

**TestAndSet 指令**：这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。指令的功能描述如下：

```c
1.  boolean TestAndSet(boolean *lock){
2.      boolean old;
3.      old = *lock;
4.      *lock=true;
5.      return old;
6.  }
```

* 可以为每个临界资源设置一个共享布尔变量 lock，表示资源的两种状态：true 表示正被占用，初值为 false。在进程访问临界资源之前，利用 TestAndSet 检查和修改标志 lock；若有进程在临界区，则重复检查，直到进程退出。利用该指令实现进程互斥的算法描述如下：

```c
1.  while TestAndSet (& 1 ock);
2.  // 进程的临界区代码段;
3.  lock=false;
4.  // 进程的其他代码
```

**Swap 指令**：该指令的功能是交换两个字节的内容。其功能描述如下。

```c
1.  Swap(boolean *a, boolean *b){  
2.      boolean temp;
3.      Temp=*a;
4.      *a = *b;
5.      *b = temp;
6.  }
```

* 注意：以上对 TestAndSet 和 Swap 指令的描述仅仅是功能实现，并非软件实现定义，事实上它们是由硬件逻辑直接实现的，不会被中断。
* 应为每个临界资源设置了一个共享布尔变量 lock，初值为 false；在每个进程中再设置一个局部布尔变量 key，用于与 lock 交换信息。在进入临界区之前先利用 Swap 指令交换 lock 与 key 的内容，然后检查 key 的状态；有进程在临界区时，重复交换和检查过程，直到进程退出。利用 Swap 指令实现进程互斥的算法描述如下：

```c
1.  key=true;
2.  while(key!=false)
3.  Swap(&lock, &key); 
4.  // 进程的临界区代码段；
5.  lock=false;
6.  // 进程的其他代码；
```

***

* 硬件方法的优点：
  * 适用于任意数目的进程，不管是单处理机还是多处理机；
  * 简单、容易验证其正确性。
  * 可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。
* 硬件方法的缺点：
  * 进程等待进入临界区时要耗费处理机时间，不能实现让权等待。
  * 从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。

## 信号量

**信号量机构是一种功能较强的机制，可用来解决互斥与同步的问题，它只能被两个标准的原语 wait(S)和 signal(S)来访问，也可以记为“P 操作”和“V 操作”。**

* 原语是指完成某种功能且不被分割不被中断执行的操作序列，通常可由硬件来实现完成不被分割执行特性的功能。如前述的“Test-and-Set”和“Swap”指令，就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机时可由软件通过屏蔽中断方法实现。
* 原语之所以不能被中断执行，是因为原语对变量的操作过程如果被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。如果能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。
* **整型信号量**
  * wait 操作中，只要信号量 S<=0，就会不断地测试。因此，该机制并未遵循“让权等待” 的准则，而是使进程处于“忙等”的状态。
  * 属于早期的信号量定义方法。无法实现唤醒一个进程的启动。
* **记录型信号量**
  * 记录型信号量是不存在“忙等”现象的进程同步机制。除了需要一个用于代表资源数目的整型变量 value 外，再增加一个进程链表 L，用于链接所有等待该资源的进程，记录型信号量是由于釆用了记录型的数据结构得名。
  * 当前最主流使用的信号量定义机制。

> 1965 年，荷兰学者 Dijkstra 提出了一种卓有成效的实现进程同步和互斥的方法 — 信号量机制（Semaphore）。信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。

* **「P 操作」**：将信号量值减 1，表示\*\*「申请占用一个资源」\*\*。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。
  * 可以这么理解，当信号量的值为 2 的时候，表示有 2 个资源可以使用，当信号量的值为 -2 的时候，表示有两个进程正在等待使用这个资源。不看这句话真的无法理解 V 操作，看完顿时如梦初醒。
* **「V 操作」**：将信号量值加 1，表示\*\*「释放一个资源」\*\*，_**即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去**_。
* _Q：信号量的值 大于 0 表示有临界资源可供使用，这个时候为什么不需要唤醒进程？_
  * 所谓唤醒进程是从就绪队列（阻塞队列）中唤醒进程，而信号量的值大于 0 表示有临界资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。
* _Q：信号量的值 等于 0 的时候表示没有临界资源可供使用，为什么还要唤醒进程_
  * V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个临界资源，我们需要唤醒它。

```c
//信号量定义
typedef struct semaphore{
    int value;  //信号量值
    struct pcb * list; //信号量队列指针
}
//P操作
void P(semaphore s){
    s.value--;
    if(s.value<0){
        asleep(s.list);
    }
}
//V操作
void V(semaphore s){
    s.value++;
    if(s.value<=0){
        wakeup(s.list);
    }
}
```

### 使用信号量实现互斥

* 两步走即可实现进程的互斥：
  * 定义一个互斥信号量，并初始化为 1
  * 把对于临界资源的访问置于 P 操作和 V 操作之间

_**互斥是最简单的信号量使用实例。只需要将同一对操作互斥信号量的原语夹住临界区即可**_

```c
semaphore mutex = 1;  //初始化互斥信号量，初始化值为1

//进程P1
P1(){
    ...
    P(mutex);  //申请占用资源
    临界区
    V(mutex);  //释放资源
}
//进程P2
P2(){
    ...
    P(mutex);  //申请占用资源
    临界区
    V(mutex);  //释放资源
}
```

**P 操作和 V 操作必须成对出现** 缺少 P 操作就不能保证对临界资源的互斥访问，缺少 V 操作就会导致临界资源永远得不到释放、处于等待态的进程永远得不到唤醒。

### 使用信号量实现同步

回顾一下进程同步，就是要各并发进程按要求有序地运行。

* 使用信号量和 PV 操作实现进程的同步也非常方便，三步走：
  * 定义一个同步信号量，并初始化为当前可用资源的数量
  * 在优先级较「高」**的操作的**「后」面执行 V 操作，释放资源
  * 在优先级较「低」**的操作的**「前」面执行 P 操作，申请占用资源

_**同步问题与此前简单的互斥问题最大的区别就在于此时的对信号量的操作决定了两个进程执行的先后顺序。一定是先释放资源，再申请使用。**_

```c
semaphore mutex = 0;  //初始化互斥信号量，初始化值为0

//进程P1
P1(){
    代码1
    代码2
    V(S);  //代码2运行完后 释放资源
    代码3
}
//进程P2
P2(){
    P(S);  //代码4运行前先申请占用资源，保证代码4一定在代码2之后运行
    代码4
    代码5
    代码6
}
```

### 生产者消费者问题

下面我们利用信号量和 PV 操作来解决经典的进程同步和互斥问题：生产者和消费者问题。

> 【问题描述】：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。任何时刻，只能有一个生产者或消费者可以访问缓冲区。

![](https://ask.qcloudimg.com/http-save/yehe-3733321/jmvgvz5br1.png?imageView2/2/w/1620)

* 由题可知，生产者、消费者共享一个初始为空、大小为 n 的缓冲区，我们从题目中提炼出同步与互斥关系：
  * **同步关系 1**：只有缓冲区没满时（优先级高），生产者才能把产品放入缓冲区（优先级低），否则必须等待——_**存数据的顺序**_
  * **同步关系 2**：只有缓冲区不空时（优先级高），消费者才能从中取出产品（优先级低），否则必须等待——_**取数据的顺序**_
  * **互斥关系**：缓冲区是临界资源，各进程必须互斥地访问。——_**临界区访问**_
* 既然这个题目有两个同步关系和一个互斥关系，那么我们就需要两个同步信号量和一个互斥信号量：
  * **empty：同步信号量**（对应同步关系 1），表示生产者还能生产多少，即还能放入缓冲区多少产品，该数量小于等于 0，则生产者不能进行生产。初始化为 n。
  * **full：同步信号量**（对应同步关系 2），表示消费者还能从缓冲区取出多少，即当前缓冲区已有产品的数量，该数量小于等于 0，则消费者不能进行读取。初始化为 0。
  * **mutex：互斥信号量**，实现对缓冲区的互斥访问。初始化为 1。

```c
semaphore empty = n;  //同步信号量
semaphore full = 0;  //同步信号量
semaphore mutex = 1;  //互斥信号量

producer(){
    while(1){
        p(empty);    //同步关系1
        p(mutex);//互斥
        把产品放入缓冲区
        v(mutex);//互斥
        v(full);  //同步关系2
    }
}

consumer(){
    while(1){
        p(full);  //同步关系2
        p(mutex);//互斥
        从缓冲区取出一个产品
        v(mutex);//互斥
        v(empty);    //同步关系1
    }
}
```

## 死锁

### 死锁的概念

**定义**

> 在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统 的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。所谓死锁是指多个进 程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。

* 死锁是指各并发进程互相等待对方所拥有的资源，且这些并发进程在得到对方资源之前不会释放自己拥有的资源。从而造成大家都想得到资源而又得不到资源。

```
先看生活中的一个实例，在一条河上有一座桥，桥面很窄，只能容纳一辆汽车通行。如 果有两辆汽车分别从桥的左右两端驶上该桥，则会出现下述的冲突情况。此时，左边的汽车 占有了桥面左边的一段，要想过桥还需等待右边的汽车让出桥面右边的一段；右边的汽车占 有了桥面右边的一段，要想过桥还需等待左边的汽车让出桥面左边的一段。此时，若左右两 边的汽车都只能向前行驶，则两辆汽车都无法过桥。  
  
在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入 设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。
```

* **死锁的起因**
  * \==死锁的起因是并发进程的资源竞争。==产生死锁的根本原因在于系统提供的资源个数少于并发进程所要求的该类资源数。
    * 只有对不可剥夺资源的竞争 才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。
    * 显然，由于资源的有限性，不可能为所有要求资源的进程无限制地提供资源。但是，可以采用适当的资源分配算法，以达到消除死锁的目的。
  * 进程推进顺序非法：
    * 进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。
  * 信号量使用不当也会造成死锁：
    * 进程间彼此相互等待对方发来的消息，结果也会使得这 些进程间无法继续向前推进。

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202208021431839.png)

### 产生死锁的必要条件

产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。

* **互斥条件**：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
* **不剥夺条件**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。
* **请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
* **循环等待条件/环路条件**：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, ..., pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0,1, ..., n-1)，Pn 等待的资源被 P0 占有，如图 2-15 所示。

```
直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所 要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, ..., n}。  
  
Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图2-16所示。因此循环等待只是死锁的必要条件。
```

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207261705920.png)

* 资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于 1。但若系统中每类资源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。

### 死锁的处理策略

**为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或者允许死锁产生， 但当死锁发生时能检测出死锁，并有能力实现恢复。**

* **预防死锁**
  * 设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个，以防止发生死锁。
* **避免死锁**
  * 在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。
* **死锁的检测和接触**
  * 无需釆取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时 地检测出死锁的发生，然后釆取某种措施解除死锁。

预防死锁和避免死锁都属于事先预防策略，但预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低；避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207261707645.png)

### 死锁预防

_**破坏死锁产生的四个必要条件中的一个或几个。最保守的措施，宁可资源闲置**_

* **破坏互斥条件**
  * 如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。
  * 所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。
* **破坏不剥夺条件**
  * 当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。
  * 该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。
  * 这种方法常用于状态易于保存和恢复的资源，如 CPU 的寄存器及内存资源，一般不能用于打印机之类的资源。
* **破坏请求和保持条件**
  * 釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。
  * 这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。
* **破坏循环等待条件**
  * 为了破坏循环等待条件，可釆用顺序资源分配法。首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源 Ri，则该进程在以后的资源申请中，只能申请编号大于 Ri 的资源。
  * 这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使甩资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。

### 死锁避免

_**用某种方法防止系统进入不安全状态，从而避免死锁。在运行时实时判断是否出现死锁**_

> Dijkstra 在 1965 年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可。为了描述银行家算法，下面先介绍一下系统的安全状态的概念。

#### 系统安全状态/序列

* 在某一时刻，系统能按照某种进程顺序，为每个进程分配其所需的资源，直至最大需求，使每个进程均可顺利完成，则称此时为安全状态，该序列为安全序列。
* 注意：
  * 系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。
  * 安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态。
* 避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，让进程等待。
* 所谓安全状态，是指系统能按某种进程推进顺序( P1, P2, ..., Pn)，为每个进程 Pi 分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序地完成。此时称 P1, P2, ..., Pn 为安全序列。如果系统无法找到一个安全序列，则称系统处于不安全状态。

**并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态**

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202208021439388.png)

#### 银行家算法

银行家算法的实质就是**要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。** 即每当进程提出资源请求且系统的资源能够满足该请求时，系统将判断满足此次资源请求后系统状态是否安全，如果判断结果为安全，则给该进程分配资源，否则不分配资源，申请资源的进程将阻塞。

* 它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。
* 操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的**最大需求量**，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。
* 银行家算法的执行前提条件：即要求进程预先提出自己的最大资源请求，并假设系统拥有固定的资源总量
* 当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。

![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202208021441416.png)

* **两张表+一次比较**
  * **一时刻的资源分配情况表——情况陈列**
  * _请求资源与 need 和 available 的比较_
    * request<=need; else 出错
    * request<=available; else 阻塞
  * **一时刻的安全性检查表——加加减减**

| Process | Max | Allocation | Need | Avaliable |
| ------- | --- | ---------- | ---- | --------- |
| P0      |     |            |      |           |
| P1      |     |            |      |           |
| P2      |     |            |      |           |
| ...     |     |            |      |           |

[操作系统——银行家算法（Banker's Algorithm） - 教材题目实例](https://www.cnblogs.com/wkfvawl/p/11929508.html)

### 死锁的检测和解除

_**允许死锁的发生，不过 OS 会负责监测出死锁的发生，然后采取某种措施解除死锁。最宽松的条件和方法**_

前面介绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不釆取任何措施，则应该提供死锁检测和解除的手段。

* **资源分配图**
  * 系统死锁，可利用资源分配图来描述。用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。
  * ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207261710825.png)
* **死锁定理**
  * 可以通过将资源分配图简化的方法来检测系统状态 S 是否为死锁状态。简化方法如下：
    * 在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。
    * 消去它所有的请求边和分配边，使之成为孤立的结点。在图 2-18(a)中，P1 是满足这一条件的进程结点，将 P1 的所有边消去，便得到图 248(b)所示的情况。
    * 进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图 2-17 中，进程 P2 就满足这样的条件。根据第 1) 条中的方法进行一系列简化后,若能消去图中所有的边，则称该图是可完全简化的，如图 2-18(c)所示。
    * **S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的,该条件为死锁定理**
* **死锁的解除**
  * 一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。死锁解除的主要方法有：
    * **资源剥夺法**。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。
    * **撤销进程法**。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。
    * **进程回退法**。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。
  * ![](https://raw.githubusercontent.com/CaesarYangs/MyPictureHotel/main/BasicImg/202207261711096.png)
